// Generated by CoffeeScript 1.6.3
var AUTOMATOR_HIDE_DEBUG, Automator, automator_log;

AUTOMATOR_HIDE_DEBUG = true;

automator_log = function(message) {
  if (!AUTOMATOR_HIDE_DEBUG) {
    return console.log(message);
  }
};

Automator = (function() {
  Automator.prototype.options = {
    namespace: "automator"
  };

  function Automator(datastore, options) {
    if (options == null) {
      options = {};
    }
    $.extend(this.options, options);
    this.datastore = datastore;
    this.categories = datastore.getTable("" + this.options.namespace + "-categories");
    this.words = datastore.getTable("" + this.options.namespace + "-words");
  }

  Automator.prototype.hasModel = function() {
    return this.categories.query().length > 0;
  };

  Automator.prototype.clearModel = function() {
    _.map(this.words.query(), function(record) {
      return record.deleteRecord();
    });
    return _.map(this.categories.query(), function(record) {
      return record.deleteRecord();
    });
  };

  Automator.prototype.train = function(text, category) {
    var self, words;
    category = category.toLowerCase();
    words = text.toLowerCase().split(" ");
    this._increment(this.categories, category);
    self = this;
    _.map(words, function(word) {
      var categoryCount, record;
      record = self._increment(self.words, word);
      categoryCount = (record.get(category)) || 0;
      return record.set(category, categoryCount + 1);
    });
  };

  Automator.prototype.trainForce = function(text, category) {
    this.train(text, category);
    if ((this.classify(text)).category !== category) {
      return this.trainUntil(text, category);
    } else {
      return automator_log("Trained");
    }
  };

  Automator.prototype.classify = function(text) {
    var confidence, maxC, maxCprime, maxP, maxPprime, self, words;
    self = this;
    maxC = "unknown";
    maxP = 0;
    maxCprime = "unknown";
    maxPprime = 0;
    words = text.toLowerCase().split(" ");
    _.map(self.categories.query(), function(record) {
      var category, p;
      category = record.get("NAME");
      p = self._getConditionalProbability(words, category);
      automator_log("" + category + ", p = " + p);
      if (p >= maxP) {
        maxCprime = maxC;
        maxPprime = maxP;
        maxC = category;
        return maxP = p;
      }
    });
    automator_log("Pmax = " + maxP);
    automator_log("Pprime = " + maxPprime);
    confidence = ((maxP - maxPprime) / maxP) || 0;
    if (confidence < 0.01) {
      return {
        category: "unknown",
        reason: [],
        confidence: confidence
      };
    }
    return {
      category: maxC,
      reason: self._getReason(words, maxC),
      confidence: confidence
    };
  };

  Automator.prototype.toJSON = function() {
    var categoryNames, propertyNames, response;
    response = {
      categories: [],
      words: []
    };
    _.map(this.categories.query(), function(record) {
      return response.categories.push({
        "NAME": record.get("NAME"),
        "COUNT": record.get("COUNT")
      });
    });
    categoryNames = _.map(response.categories, function(category) {
      return category.NAME;
    });
    propertyNames = categoryNames.concat("NAME", "COUNT");
    _.map(this.words.query(), function(record) {
      var word;
      word = {};
      _.map(propertyNames, function(property) {
        var val;
        val = record.get(property);
        if (val !== null) {
    